{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport { primitives as isIntegerArray } from '@stdlib/assert-is-integer-array';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport resolveStr from '@stdlib/ndarray-base-dtype-resolve-str';\nimport join from '@stdlib/array-base-join';\nimport contains from '@stdlib/array-base-assert-contains';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {NonNegativeInteger} ndims - number of input ndarray dimensions\n* @param {Array} dtypes - list of supported output data types\n* @param {Options} options - function options\n* @param {boolean} [options.keepdims] - boolean indicating whether the reduced dimensions should be included in the returned ndarray as singleton dimensions\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @param {*} [options.dtype] - output ndarray data type\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var dtypes = [ 'float64', 'float32', 'generic' ];\n*\n* var opts = {};\n* var options = {\n*     'keepdims': true\n* };\n* var err = validate( opts, 3, dtypes, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, ndims, dtypes, options ) {\n\tvar tmp;\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'keepdims' ) ) {\n\t\topts.keepdims = options.keepdims;\n\t\tif ( !isBoolean( opts.keepdims ) ) {\n\t\t\treturn new TypeError( format( 'null2o', 'keepdims', opts.keepdims ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'dims' ) ) {\n\t\topts.dims = options.dims;\n\t\tif ( !isIntegerArray( opts.dims ) && !isEmptyCollection( opts.dims ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be an array of integers. Option: `%s`.', 'dims', opts.dims ) );\n\t\t}\n\t\ttmp = normalizeIndices( opts.dims, ndims-1 );\n\t\tif ( tmp === null ) {\n\t\t\treturn new RangeError( format( 'invalid option. `%s` option contains an out-of-bounds dimension index. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\tif ( tmp.length !== opts.dims.length ) {\n\t\t\treturn new Error( format( 'invalid option. `%s` option contains duplicate indices. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\topts.dims = tmp;\n\t}\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\topts.dtype = options.dtype;\n\t\tif ( !contains( dtypes, resolveStr( opts.dtype ) ) ) {\n\t\t\treturn new TypeError( format( 'null4S', 'dtype', join( dtypes, '\", \"' ), opts.dtype ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this, max-lines, id-length, no-warning-comments */\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport hasProp from '@stdlib/assert-has-property';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport isObject from '@stdlib/assert-is-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport isFunctionArray from '@stdlib/assert-is-function-array';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport isOutputDataTypePolicy from '@stdlib/ndarray-base-assert-is-output-data-type-policy';\nimport isInputCastingPolicy from '@stdlib/ndarray-base-assert-is-input-casting-policy';\nimport isEqualDataType from '@stdlib/ndarray-base-assert-is-equal-data-type';\nimport contains from '@stdlib/array-base-assert-contains';\nimport binaryReduceStrided1d from '@stdlib/ndarray-base-binary-reduce-strided1d';\nimport binaryOutputDataType from '@stdlib/ndarray-base-binary-output-dtype';\nimport binaryInputCastingDataType from '@stdlib/ndarray-base-binary-input-casting-dtype';\nimport dtypes2enums from '@stdlib/ndarray-base-dtypes2enums';\nimport dtypes2strings from '@stdlib/ndarray-base-dtypes2strings';\nimport resolveStr from '@stdlib/ndarray-base-dtype-resolve-str';\nimport spreadDimensions from '@stdlib/ndarray-base-spread-dimensions';\nimport getShape from '@stdlib/ndarray-shape'; // note: non-base accessor is intentional due to input ndarrays originating in userland\nimport ndims from '@stdlib/ndarray-ndims';\nimport getDType from '@stdlib/ndarray-base-dtype';\nimport getOrder from '@stdlib/ndarray-base-order';\nimport assign from '@stdlib/ndarray-base-assign';\nimport baseEmpty from '@stdlib/ndarray-base-empty';\nimport empty from '@stdlib/ndarray-empty';\nimport indicesComplement from '@stdlib/array-base-indices-complement';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport join from '@stdlib/array-base-join';\nimport copy from '@stdlib/array-base-copy';\nimport insertAt from '@stdlib/array-base-insert-at';\nimport everyBy from '@stdlib/array-base-every-by';\nimport { ndarray as gindexOfRow } from '@stdlib/blas-ext-base-gindex-of-row';\nimport objectAssign from '@stdlib/object-assign';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport defaults from '@stdlib/ndarray-defaults';\nimport DEFAULTS from './defaults.json';\nimport validate from './validate.js';\n\n\n// VARIABLES //\n\nvar DEFAULT_ORDER = defaults.get( 'order' );\n\n\n// MAIN //\n\n/**\n* Constructor for performing a reduction on two input ndarrays.\n*\n* @constructor\n* @param {Object} table - dispatch table\n* @param {Function} table.default - default strided reduction function\n* @param {Array} [table.types=[]] - one-dimensional list of ndarray data types describing specialized input ndarray argument signatures\n* @param {ArrayLikeObject<Function>} [table.fcns=[]] - list of strided reduction functions which are specific to specialized input ndarray argument signatures\n* @param {ArrayLikeObject<Array>} idtypes - list containing lists of supported input data types for each input ndarray argument\n* @param {Array} odtypes - list of supported output data types\n* @param {Object} policies - policies\n* @param {string} policies.output - output data type policy\n* @param {string} policies.casting - input ndarray casting policy\n* @throws {TypeError} first argument must be an object having valid properties\n* @throws {TypeError} second argument must be an array containing arrays of supported data types\n* @throws {TypeError} third argument must be an array of supported data types\n* @throws {TypeError} fourth argument must be an object having supported policies\n* @throws {Error} first argument must be an object having valid properties\n* @returns {BinaryStrided1dDispatch} instance\n*\n* @example\n* import base from '@stdlib/blas-base-ndarray-gdot';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'promoted',\n*     'casting': 'promoted'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var dot = new BinaryStrided1dDispatch( table, [ idt, idt ], odt, policies );\n*\n* var xbuf = [ 4.0, 2.0, -3.0, 5.0, -1.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var ybuf = [ 2.0, 6.0, -1.0, -4.0, 8.0 ];\n* var y = new ndarray( 'generic', ybuf, [ ybuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var z = dot.apply( x, y );\n* // returns <ndarray>[ -5.0 ]\n*/\nfunction BinaryStrided1dDispatch( table, idtypes, odtypes, policies ) {\n\tvar dt;\n\tvar i;\n\tif ( !( this instanceof BinaryStrided1dDispatch ) ) {\n\t\treturn new BinaryStrided1dDispatch( table, idtypes, odtypes, policies );\n\t}\n\tif ( !isObject( table ) ) {\n\t\tthrow new TypeError( format( 'null3L', table ) );\n\t}\n\tif ( !isFunction( table.default ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"default\" property and an associated method.' ) );\n\t}\n\tif ( hasProp( table, 'types' ) && !isCollection( table.types ) && !isEmptyCollection( table.types ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"types\" property whose associated value is an array-like object.' ) );\n\t}\n\tif ( hasProp( table, 'fcns' ) && !isFunctionArray( table.fcns ) && !isEmptyCollection( table.fcns ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"fcns\" property whose associated value is an array-like object containing functions.' ) );\n\t}\n\tif ( !isCollection( idtypes ) ) {\n\t\tthrow new TypeError( format( 'null2y', idtypes ) );\n\t}\n\tidtypes = copy( idtypes );\n\tfor ( i = 0; i < idtypes.length; i++ ) {\n\t\tdt = idtypes[ i ];\n\t\tif (\n\t\t\t!isCollection( dt ) ||\n\t\t\tdt.length < 1 ||\n\t\t\t!everyBy( dt, isDataType )\n\t\t) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must contain arrays of data types. Value: `%s`.', idtypes ) );\n\t\t}\n\t\tidtypes[ i ] = dtypes2strings( dt );\n\t}\n\tif (\n\t\t!isCollection( odtypes ) ||\n\t\todtypes.length < 1 ||\n\t\t!everyBy( odtypes, isDataType )\n\t) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array of data types. Value: `%s`.', odtypes ) );\n\t}\n\todtypes = dtypes2strings( odtypes );\n\n\tif ( !isObject( policies ) ) {\n\t\tthrow new TypeError( format( 'null43', table ) );\n\t}\n\tif ( !isOutputDataTypePolicy( policies.output ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported output data type policy. Value: `%s`.', policies.output ) );\n\t}\n\tif ( !isInputCastingPolicy( policies.casting ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported casting policy. Value: `%s`.', policies.casting ) );\n\t}\n\tthis._table = {\n\t\t'default': table.default,\n\t\t'types': ( table.types ) ? dtypes2enums( table.types ) : [], // note: convert to enums (i.e., integers) to ensure faster comparisons\n\t\t'fcns': ( table.fcns ) ? copy( table.fcns ) : []\n\t};\n\tif ( this._table.types.length !== 2 * this._table.fcns.length ) {\n\t\tthrow new Error( 'invalid argument. First argument specifies an unexpected number of types. Two input ndarray data types must be specified for each provided strided function.' );\n\t}\n\tthis._idtypes = idtypes;\n\tthis._odtypes = odtypes;\n\tthis._policies = {\n\t\t'output': policies.output,\n\t\t'casting': policies.casting\n\t};\n\treturn this;\n}\n\n/**\n* Performs a reduction on two provided input ndarrays.\n*\n* @name apply\n* @memberof BinaryStrided1dDispatch.prototype\n* @type {Function}\n* @param {ndarrayLike} x - first input ndarray\n* @param {ndarrayLike} y - second input ndarray\n* @param {...ndarrayLike} [args] - additional ndarray arguments\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @param {boolean} [options.keepdims=false] - boolean indicating whether the reduced dimensions should be included in the returned ndarray as singleton dimensions\n* @param {*} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} second argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import base from '@stdlib/blas-base-ndarray-gdot';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'promoted',\n*     'casting': 'promoted'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var dot = new BinaryStrided1dDispatch( table, [ idt, idt ], odt, policies );\n*\n* var xbuf = [ 4.0, 2.0, -3.0, 5.0, -1.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var ybuf = [ 2.0, 6.0, -1.0, -4.0, 8.0 ];\n* var y = new ndarray( 'generic', ybuf, [ ybuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var z = dot.apply( x, y );\n* // returns <ndarray>[ -5.0 ]\n*/\nsetReadOnly( BinaryStrided1dDispatch.prototype, 'apply', function apply( x, y ) {\n\tvar options;\n\tvar nargs;\n\tvar args;\n\tvar opts;\n\tvar ordx;\n\tvar ordy;\n\tvar ordz;\n\tvar err;\n\tvar idx;\n\tvar shx;\n\tvar shy;\n\tvar shz;\n\tvar arr;\n\tvar tmp;\n\tvar xdt;\n\tvar ydt;\n\tvar zdt;\n\tvar dt;\n\tvar f;\n\tvar N;\n\tvar z;\n\tvar i;\n\tvar j;\n\n\tnargs = arguments.length;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'null5t', x ) );\n\t}\n\tif ( !isndarrayLike( y ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an ndarray-like object. Value: `%s`.', y ) );\n\t}\n\txdt = getDType( x );\n\tif ( !contains( this._idtypes[ 0 ], resolveStr( xdt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 0 ], '\", \"' ), xdt ) );\n\t}\n\tydt = getDType( y );\n\tif ( !contains( this._idtypes[ 1 ], resolveStr( ydt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 1 ], '\", \"' ), ydt ) );\n\t}\n\targs = [ x, y ];\n\tfor ( i = 2; i < nargs; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tif ( !isndarrayLike( arr ) ) {\n\t\t\tbreak;\n\t\t}\n\t\tdt = getDType( arr );\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( dt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument %d must have one of the following data types: \"%s\". Data type: `%s`.', i, join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t\t// Note: we don't type promote additional ndarray arguments, as they are passed as scalars to the underlying strided reduction function...\n\t\targs.push( arr );\n\t}\n\t// If we didn't make it up until the last argument, this means that we found a non-options argument which was not an ndarray...\n\tif ( i < nargs-1 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Argument %d must be an ndarray-like object. Value: `%s`.', i, arguments[ i ] ) );\n\t}\n\t// Verify that both input arrays have the same shape:\n\tshx = getShape( x );\n\tshy = getShape( y );\n\tif ( shx.length !== shy.length ) {\n\t\tthrow new Error( format( 'invalid argument. Input arrays must have the same number of dimensions. First array dimensions: %d. Second array dimensions: %d.', shx.length, shy.length ) );\n\t}\n\tN = shx.length;\n\tfor ( j = 0; j < N; j++ ) {\n\t\tif ( shx[ j ] !== shy[ j ] ) {\n\t\t\tthrow new Error( format( 'invalid argument. Input arrays must have the same shape. First array shape: [%s]. Second array shape: [%s].', join( shx, ',' ), join( shy, ',' ) ) );\n\t\t}\n\t}\n\t// Validate any provided options...\n\topts = objectAssign( {}, DEFAULTS );\n\tif ( nargs > i ) {\n\t\toptions = arguments[ nargs-1 ];\n\t\terr = validate( opts, N, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t// When a list of dimensions is not provided, reduce the input ndarrays across all dimensions...\n\tif ( opts.dims === null ) {\n\t\topts.dims = zeroTo( N );\n\t}\n\t// Resolve the list of non-reduced dimensions:\n\tidx = indicesComplement( N, opts.dims );\n\n\t// Resolve the output array shape:\n\tshz = takeIndexed( shx, idx );\n\n\t// Resolve the output array order:\n\tordx = getOrder( x );\n\tordy = getOrder( y );\n\tif ( ordx === ordy ) {\n\t\tordz = ordx;\n\t} else {\n\t\t// When the orders differ, fall back to the default order:\n\t\tordz = DEFAULT_ORDER;\n\t}\n\t// Initialize an output array whose shape matches that of the non-reduced dimensions:\n\tzdt = opts.dtype || binaryOutputDataType( xdt, ydt, this._policies.output );\n\tz = empty( shz, {\n\t\t'dtype': zdt,\n\t\t'order': ordz\n\t});\n\n\t// Determine whether we need to cast the input ndarrays...\n\tdt = binaryInputCastingDataType( xdt, ydt, zdt, this._policies.casting );\n\tif ( !isEqualDataType( xdt, dt ) ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, shx, ordx );\n\t\tassign( [ x, tmp ] );\n\t\targs[ 0 ] = tmp;\n\t\txdt = dt;\n\t}\n\tdt = binaryInputCastingDataType( ydt, xdt, zdt, this._policies.casting );\n\tif ( !isEqualDataType( ydt, dt ) ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, shy, ordy );\n\t\tassign( [ y, tmp ] );\n\t\targs[ 1 ] = tmp;\n\t\tydt = dt;\n\t}\n\t// Resolve the lower-level strided function satisfying the input ndarray data types:\n\ti = gindexOfRow( this._table.fcns.length, 2, this._table.types, 2, 1, 0, dtypes2enums( [ xdt, ydt ] ), 1, 0 ); // eslint-disable-line max-len\n\tif ( i >= 0 ) {\n\t\tf = this._table.fcns[ i ];\n\t} else {\n\t\tf = this._table.default;\n\t}\n\t// Perform the reduction:\n\tbinaryReduceStrided1d( f, insertAt( args, 2, z ), opts.dims );\n\n\t// Check whether we need to reinsert singleton dimensions which can be useful for broadcasting the returned output array to the shape of the original input array...\n\tif ( opts.keepdims ) {\n\t\tz = spreadDimensions( N, z, idx, true );\n\t}\n\treturn z;\n});\n\n/**\n* Performs a reduction on two provided input ndarrays and assigns results to a provided output ndarray.\n*\n* @name assign\n* @memberof BinaryStrided1dDispatch.prototype\n* @type {Function}\n* @param {ndarrayLike} x - first input ndarray\n* @param {ndarrayLike} y - second input ndarray\n* @param {...ndarrayLike} [args] - additional ndarray arguments\n* @param {ndarrayLike} out - output ndarray\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @throws {TypeError} first argument must be an ndarray\n* @throws {TypeError} first argument must have a supported data type\n* @throws {TypeError} second argument must be an ndarray\n* @throws {TypeError} second argument must have a supported data type\n* @throws {TypeError} output argument must be an ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarrayLike} output ndarray\n*\n* @example\n* import base from '@stdlib/blas-base-ndarray-gdot';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'promoted',\n*     'casting': 'promoted'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var dot = new BinaryStrided1dDispatch( table, [ idt, idt ], odt, policies );\n*\n* var xbuf = [ 4.0, 2.0, -3.0, 5.0, -1.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var ybuf = [ 2.0, 6.0, -1.0, -4.0, 8.0 ];\n* var y = new ndarray( 'generic', ybuf, [ ybuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var zbuf = [ 0.0 ];\n* var z = new ndarray( 'generic', zbuf, [], [ 0 ], 0, 'row-major' );\n*\n* var out = dot.assign( x, y, z );\n* // returns <ndarray>[ -5.0 ]\n*\n* var bool = ( out === z );\n* // returns true\n*/\nsetReadOnly( BinaryStrided1dDispatch.prototype, 'assign', function assign( x, y ) {\n\tvar options;\n\tvar nargs;\n\tvar opts;\n\tvar args;\n\tvar arr;\n\tvar err;\n\tvar flg;\n\tvar shx;\n\tvar shy;\n\tvar xdt;\n\tvar ydt;\n\tvar zdt;\n\tvar tmp;\n\tvar dt;\n\tvar N;\n\tvar f;\n\tvar z;\n\tvar i;\n\tvar j;\n\n\tnargs = arguments.length;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'null5t', x ) );\n\t}\n\tif ( !isndarrayLike( y ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an ndarray-like object. Value: `%s`.', y ) );\n\t}\n\t// Validate the input ndarray data types in order to maintain similar behavior to `apply` above...\n\txdt = getDType( x );\n\tif ( !contains( this._idtypes[ 0 ], resolveStr( xdt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 0 ], '\", \"' ), xdt ) );\n\t}\n\tydt = getDType( y );\n\tif ( !contains( this._idtypes[ 1 ], resolveStr( ydt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 1 ], '\", \"' ), ydt ) );\n\t}\n\t// Verify that both input arrays have the same shape:\n\tshx = getShape( x );\n\tshy = getShape( y );\n\tif ( shx.length !== shy.length ) {\n\t\tthrow new Error( format( 'invalid argument. Input arrays must have the same number of dimensions. First array dimensions: %d. Second array dimensions: %d.', shx.length, shy.length ) );\n\t}\n\tN = shx.length;\n\tfor ( j = 0; j < N; j++ ) {\n\t\tif ( shx[ j ] !== shy[ j ] ) {\n\t\t\tthrow new Error( format( 'invalid argument. Input arrays must have the same shape. First array shape: [%s]. Second array shape: [%s].', join( shx, ',' ), join( shy, ',' ) ) );\n\t\t}\n\t}\n\targs = [ x, y ];\n\n\t// Resolve additional ndarray arguments...\n\tfor ( i = 2; i < nargs; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tif ( !isndarrayLike( arr ) ) {\n\t\t\tbreak;\n\t\t}\n\t\targs.push( arr );\n\t}\n\t// Ensure that we were provided an output ndarray...\n\tif ( i < 3 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an ndarray-like object. Value: `%s`.', arguments[ 2 ] ) );\n\t}\n\t// If we processed all but the last argument, assume that the last argument is an options argument...\n\telse if ( i === nargs-1 ) {\n\t\toptions = arguments[ i ];\n\t\tflg = true;\n\t}\n\t// Otherwise, if we have more than one argument remaining, then at least one argument is not an ndarray but should be...\n\telse if ( i < nargs-1 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Argument %d must be an ndarray-like object. Value: `%s`.', i, arguments[ i ] ) );\n\t}\n\t// Cache a reference to the output ndarray:\n\tz = args.pop();\n\n\t// Verify that additional ndarray arguments have expected dtypes (note: we intentionally don't validate the output ndarray dtype in order to provide an escape hatch for a user wanting to have an output ndarray having a specific dtype that `apply` does not support; note: we don't type promote additional ndarray arguments, as they are passed as scalars to the underlying strided reduction function)...\n\tfor ( i = 2; i < args.length; i++ ) {\n\t\tdt = getDType( args[ i ] );\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( dt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument %d must have one of the following data types: \"%s\". Data type: `%s`.', i, join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t}\n\t// Validate any provided options...\n\tN = ndims( x );\n\topts = objectAssign( {}, DEFAULTS );\n\tif ( flg ) {\n\t\terr = validate( opts, N, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t// When a list of dimensions is not provided, reduce the input arrays across all dimensions...\n\tif ( opts.dims === null ) {\n\t\topts.dims = zeroTo( N );\n\t}\n\t// Determine whether we need to cast the input ndarrays...\n\tzdt = getDType( z );\n\tdt = binaryInputCastingDataType( xdt, ydt, zdt, this._policies.casting );\n\tif ( !isEqualDataType( xdt, dt ) ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, shx, getOrder( x ) );\n\t\tassign( [ x, tmp ] );\n\t\targs[ 0 ] = tmp;\n\t\txdt = dt;\n\t}\n\tdt = binaryInputCastingDataType( ydt, xdt, zdt, this._policies.casting );\n\tif ( !isEqualDataType( ydt, dt ) ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, shy, getOrder( y ) );\n\t\tassign( [ y, tmp ] );\n\t\targs[ 1 ] = tmp;\n\t\tydt = dt;\n\t}\n\t// Resolve the lower-level strided function satisfying the input ndarray data type:\n\ti = gindexOfRow( this._table.fcns.length, 2, this._table.types, 2, 1, 0, dtypes2enums( [ xdt, ydt ] ), 1, 0 ); // eslint-disable-line max-len\n\tif ( i >= 0 ) {\n\t\tf = this._table.fcns[ i ];\n\t} else {\n\t\tf = this._table.default;\n\t}\n\t// Perform the reduction:\n\tbinaryReduceStrided1d( f, insertAt( args, 2, z ), opts.dims ); // note: we assume that this lower-level function handles further validation of the output ndarray (e.g., expected shape, etc)\n\n\treturn z;\n});\n\n\n// EXPORTS //\n\nexport default BinaryStrided1dDispatch;\n"],"names":["validate","opts","ndims","dtypes","options","tmp","isObject","TypeError","format","hasOwnProp","keepdims","isBoolean","dims","isIntegerArray","isEmptyCollection","normalizeIndices","RangeError","join","length","Error","dtype","contains","resolveStr","DEFAULT_ORDER","defaults","get","BinaryStrided1dDispatch","table","idtypes","odtypes","policies","dt","i","this","isFunction","default","hasProp","isCollection","types","isFunctionArray","fcns","copy","everyBy","isDataType","dtypes2strings","isOutputDataTypePolicy","output","isInputCastingPolicy","casting","_table","dtypes2enums","_idtypes","_odtypes","_policies","setReadOnly","prototype","x","y","nargs","args","ordx","ordy","ordz","err","idx","shx","shy","shz","arr","xdt","ydt","zdt","f","N","z","j","arguments","isndarrayLike","getDType","push","getShape","objectAssign","DEFAULTS","zeroTo","indicesComplement","takeIndexed","getOrder","binaryOutputDataType","empty","order","binaryInputCastingDataType","isEqualDataType","baseEmpty","assign","gindexOfRow","binaryReduceStrided1d","insertAt","spreadDimensions","flg","pop"],"mappings":"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"}